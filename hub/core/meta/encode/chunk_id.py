from hub.constants import ENCODING_DTYPE, UUID_SHIFT_AMOUNT
from hub.util.exceptions import ChunkIdEncoderError
import hub
from hub.core.storage.cachable import Cachable
from io import BytesIO
from typing import Optional, Tuple, Union
import numpy as np
from uuid import uuid4
from hub.core.lowlevel import encode_chunkids, decode_chunkids


# these constants are for accessing the data layout. see the `ChunkIdEncoder` docstring.
CHUNK_ID_INDEX = 0
LAST_INDEX_INDEX = 1


class ChunkIdEncoder(Cachable):
    def __init__(self):
        """Custom compressor that allows reading of chunk IDs from a sample index without decompressing.

        Chunk IDs:
            Chunk IDs are a `ENCODING_DTYPE` value  and this class handles generating/encoding them.

        Layout:
            `_encoded_ids` is a 2D array.

            Rows:
                The number of rows is equal to the number of chunk IDs this encoder is responsible for.

            Columns:
                The number of columns is 2.
                Each row looks like this: [chunk_id, last_index], where `last_index` is the last index that the
                chunk with `chunk_id` contains.

            Example:
                >>> enc = ChunkIdEncoder()
                >>> enc.generate_chunk_id()
                >>> enc.num_chunks
                1
                >>> enc.register_samples_to_last_chunk_id(10)
                >>> enc.num_samples
                10
                >>> enc.register_samples_to_last_chunk_id(10)
                >>> enc.num_samples
                20
                >>> enc.num_chunks
                1
                >>> enc.generate_chunk_id()
                >>> enc.register_samples_to_last_chunk_id(1)
                >>> enc.num_samples
                21
                >>> enc._encoded_ids
                [[3723322941, 19],
                 [1893450271, 20]]
                >>> enc[20]
                1893450271

            Best case scenario:
                The best case scenario is when all samples fit within a single chunk. This means the number of rows is 1,
                providing a O(1) lookup.

            Worst case scenario:
                The worst case scenario is when only 1 sample fits per chunk. This means the number of rows is equal to the number
                of samples, providing a O(log(N)) lookup.

            Lookup algorithm:
                To get the chunk ID for some sample index, you do a binary search over the right-most column. This will give you
                the row that corresponds to that sample index (since the right-most column is our "last index" for that chunk ID).
                Then, you get the left-most column and that is your chunk ID!

        """
        self._shards: List[np.ndarray] = []
        self._buffer: List[List(int, int)] = []

    def _flush_buffer(self):
        if self._buffer:
            self._shards.append(np.array(self._buffer, dtype=ENCODING_DTYPE))
        self._buffer.clear()

    def _get_2d_idx(self, idx: int) -> Tuple[int, int]:
        i = 0
        data = self._shards
        while True:
            try:
                num_data_i = len(data[i])
            except IndexError:  # slightly faster than checking i < len(self._data) in a loop
                return -1, idx
            if num_data_i <= idx:
                idx -= num_data_i
                i += 1
            else:
                break
        return i, idx

    def tobytes(self) -> memoryview:
        self._flush_buffer()
        return encode_chunkids(
            hub.__version__,
            self._shards
        )

    @staticmethod
    def name_from_id(id: ENCODING_DTYPE) -> str:
        """Returns the hex of `id` with the "0x" prefix removed. This is the chunk's name and should be used to determine the chunk's key.
        Can convert back into `id` using `id_from_name`. You can get the `id` for a chunk using `__getitem__`."""

        return hex(id)[2:]

    @staticmethod
    def id_from_name(name: str) -> ENCODING_DTYPE:
        """Returns the 64-bit integer from the hex `name` generated by `name_from_id`."""

        return int("0x" + name, 16)

    def get_name_for_chunk(self, chunk_index: int) -> str:
        """Gets the name for the chunk at index `chunk_index`. If you need to get the name for a chunk from a sample index, instead
        use `__getitem__`, then `name_from_id`."""
        chunk_id = self.get_entry(chunk_index)[CHUNK_ID_INDEX]
        return ChunkIdEncoder.name_from_id(chunk_id)

    @classmethod
    def frombuffer(cls, buffer: bytes):
        version, ids = decode_chunkids(buffer)
        instance = cls()
        instance._shards = [ids]
        return instance

    @property
    def num_chunks(self) -> int:
        return sum(map(len, self._shards)) + len(self._buffer)

    def get_entry(self, idx):
        x, y = self._get_2d_idx(idx)
        return self._buffer[y] if x < 0 else self._shards[x][y]

    @property
    def last_entry(self) -> int:
        if self._buffer:
            return self._buffer[-1]
        if self._shards:
            return self._shards[-1][-1]

    @property
    def last_index(self) -> int:
        last_entry = self.last_entry
        if not last_entry:
            return -1
        return last_entry[LAST_INDEX_INDEX]

    @property
    def num_samples(self) -> int:
        return self.last_index + 1

    def generate_chunk_id(self) -> ENCODING_DTYPE:
        """Generates a random 64bit chunk ID using uuid4. Also prepares this ID to have samples registered to it.
        This method should be called once per chunk created.

        Returns:
            ENCODING_DTYPE: The random chunk ID.
        """

        id = ENCODING_DTYPE(uuid4().int >> UUID_SHIFT_AMOUNT)
        self._buffer.append([id, self.last_index])
        return id


    def register_samples_to_last_chunk_id(self, num_samples: int):
        """Registers samples to the chunk ID that was generated last with the `generate_chunk_id` method.
        This method should be called at least once per chunk created.

        Args:
            num_samples (int): The number of samples the last chunk ID should have added to it's registration.

        Raises:
            ValueError: `num_samples` should be non-negative.
            ChunkIdEncoderError: Must call `generate_chunk_id` before registering samples.
            ChunkIdEncoderError: `num_samples` can only be 0 if it is able to be a sample continuation accross chunks.
        """

        if num_samples < 0:
            raise ValueError(
                f"Cannot register negative num samples. Got: {num_samples}"
            )

        if self.num_samples == 0:
            raise ChunkIdEncoderError(
                "Cannot register samples because no chunk IDs exist."
            )

        if num_samples == 0 and self.num_chunks < 2:
            raise ChunkIdEncoderError(
                "Cannot register 0 num_samples (signifying a partial sample continuing the last chunk) when no last chunk exists."
            )

        current_entry = self.last_entry

        # this operation will trigger an overflow for the first addition, so supress the warning
        # np.seterr(over="ignore")
        self.last_entry[LAST_INDEX_INDEX] += num_samples
        # np.seterr(over="warn")

    def get_local_sample_index(self, global_sample_index: int) -> int:
        """Converts `global_sample_index` into a new index that is relative to the chunk the sample belongs to.

        Example:
            Given: 2 sampes in chunk 0, 2 samples in chunk 1, and 3 samples in chunk 2.

            >>> self.num_samples
            7
            >>> self.num_chunks
            3
            >>> self.get_local_sample_index(0)
            0
            >>> self.get_local_sample_index(1)
            1
            >>> self.get_local_sample_index(2)
            0
            >>> self.get_local_sample_index(3)
            1
            >>> self.get_local_sample_index(6)
            2

        Args:
            global_sample_index (int): Index of the sample relative to the containing tensor.

        Returns:
            int: local index value between 0 and the amount of samples the chunk contains - 1.
        """

        _, (shard_index, chunk_index) = self.get(global_sample_index, return_chunk_index=True)  # type: ignore

        if not shard_index and not chunk_index:
            return global_sample_index

        # current_entry = self._encoded_ids[chunk_index - 1]
        current_entry = self._shards[shard_index][chunk_index - 1]  # buffer already flushed by get() call
        last_num_samples = current_entry[LAST_INDEX_INDEX] + 1

        return global_sample_index - int(last_num_samples)

    def __getitem__(self, sample_index: int) -> int:
        return self.get(sample_index)

    def get(
        self, sample_index: int, return_chunk_index: bool = False
    ) -> Union[int, Tuple[int, Tuple[int, int]]]:
        """Get the ID for the chunk that `sample_index` is stored in.
        To get the name of the chunk, use `name_from_id`.

        Args:
            sample_index (int): Global index (relative to the tensor). This will be converted to the local chunk index.
            return_chunk_index (bool): If True, 2 values are returned, the second one being the chunk's index. Defaults to False.

        Raises:
            IndexError: If no samples exist or `sample_index` exceeds the available indices.

        Returns:
            Tuple[Tuple[ENCODING_DTYPE], Optional[Tuple[int]]]: Returns the chunk ID for `sample_index`. If `return_chunk_index` is True,
                there will be 2 values. The second one being the chunk's index.
        """

        if self.num_samples == 0:
            raise IndexError(
                f"Index {sample_index} is out of bounds for an empty chunk names encoding."
            )

        if sample_index < 0:
            sample_index = (self.num_samples) + sample_index

        self._flush_buffer()
        last_idxs = [shard[-1, LAST_INDEX_INDEX] for shard in self._shards]
        shard_idx = bp.searchsorted(last_idxs, sample_index)
        shard = self._shards[shard_idx]
        idx = np.searchsorted(shard[:, LAST_INDEX_INDEX], sample_index)
        id = shard[idx, CHUNK_ID_INDEX]
        chunk_index = idx

        if return_chunk_index:
            return id, (shard_idx, chunk_index)

        return id
